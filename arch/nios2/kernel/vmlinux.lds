

/*
 * Automatically generated C config: don't edit
 * Linux kernel version: 2.6.21.7-hrt1
 * Mon May  4 16:31:53 2009
 */



/* Align . to a 8 byte boundary equals to maximum function alignment. */
/* sched.text is aling to function alignment to secure we have same
 * address even at second ld pass when generating System.map */
/* spinlock.text is aling to function alignment to secure we have same
 * address even at second ld pass when generating System.map */
  /* DWARF debug sections.
		Symbols in the DWARF debugging sections are relative to
		the beginning of the section so we begin them at 0.  */
  /* Stabs debugging sections.  */
/* Note, this file was manually edited after generation
 * since the multiple inclusion proctetion macro above collides with
 * include/linux/cpu.h
 */
/*
 * This file was automatically generated by the swinfo2header utility.
 *
 * Created from SOPC Builder system 'nios2_linux_3c120_125mhz_sys_sopc' in
 * file 'default//nios2_linux_3c120_125mhz_sys_sopc.sopcinfo'.
 */
/*
 * This file contains macros for module 'linux_cpu' and devices
 * connected to the following masters:
 *   instruction_master
 *   tightly_coupled_instruction_master_0
 *   data_master
 *   tightly_coupled_data_master_0
 *
 * Do not #include this header file and another header file created for a
 * different module or master group at the same time.
 * Doing so may result in duplicate #defines.
 * Instead, use the system header file which has #defines with unique names.
 */
/*
 * Macros for module 'linux_cpu', class 'altera_nios2'.
 * The macros have no prefix.
 */
/*
 * Macros for device 'cfi_flash_64m', class 'altera_avalon_cfi_flash'
 * The macros are prefixed with 'CFI_FLASH_64M_'.
 * The prefix is the slave descriptor.
 */
/*
 * Macros for device 'fast_tlb_miss_ram_1k', class 'altera_avalon_onchip_memory2'
 * The macros are prefixed with 'FAST_TLB_MISS_RAM_1K_'.
 * The prefix is the slave descriptor.
 */
/*
 * Macros for device 'descriptor_memory', class 'altera_avalon_onchip_memory2'
 * The macros are prefixed with 'DESCRIPTOR_MEMORY_'.
 * The prefix is the slave descriptor.
 */
/*
 * Macros for device 'tse_mac', class 'triple_speed_ethernet'
 * The macros are prefixed with 'TSE_MAC_'.
 * The prefix is the slave descriptor.
 */
/*
 * Macros for device 'sgdma_rx', class 'altera_avalon_sgdma'
 * The macros are prefixed with 'SGDMA_RX_'.
 * The prefix is the slave descriptor.
 */
/*
 * Macros for device 'ddr2_lo_latency_128m', class 'altmemddr2'
 * Path to the device is from the master group 'sgdma_rx_m_write'.
 * The macros are prefixed with 'SGDMA_RX_M_WRITE_DDR2_LO_LATENCY_128M_'.
 * The prefix is the master group descriptor and the slave descriptor.
 */
/*
 * Macros for device 'sgdma_tx', class 'altera_avalon_sgdma'
 * The macros are prefixed with 'SGDMA_TX_'.
 * The prefix is the slave descriptor.
 */
/*
 * Macros for device 'ddr2_lo_latency_128m', class 'altmemddr2'
 * Path to the device is from the master group 'sgdma_tx_m_read'.
 * The macros are prefixed with 'SGDMA_TX_M_READ_DDR2_LO_LATENCY_128M_'.
 * The prefix is the master group descriptor and the slave descriptor.
 */
/*
 * Macros for device 'uart', class 'altera_avalon_uart'
 * The macros are prefixed with 'UART_'.
 * The prefix is the slave descriptor.
 */
/*
 * Macros for device 'user_led_pio_8out', class 'altera_avalon_pio'
 * The macros are prefixed with 'USER_LED_PIO_8OUT_'.
 * The prefix is the slave descriptor.
 */
/*
 * Macros for device 'user_dipsw_pio_8in', class 'altera_avalon_pio'
 * The macros are prefixed with 'USER_DIPSW_PIO_8IN_'.
 * The prefix is the slave descriptor.
 */
/*
 * Macros for device 'user_pb_pio_4in', class 'altera_avalon_pio'
 * The macros are prefixed with 'USER_PB_PIO_4IN_'.
 * The prefix is the slave descriptor.
 */
/*
 * Macros for device 'sysid', class 'altera_avalon_sysid'
 * The macros are prefixed with 'SYSID_'.
 * The prefix is the slave descriptor.
 */
/*
 * Macros for device 'jtag_uart', class 'altera_avalon_jtag_uart'
 * The macros are prefixed with 'JTAG_UART_'.
 * The prefix is the slave descriptor.
 */
/*
 * Macros for device 'linux_timer_1ms', class 'altera_avalon_timer'
 * The macros are prefixed with 'LINUX_TIMER_1MS_'.
 * The prefix is the slave descriptor.
 */
/*
 * Macros for device 'ddr2_lo_latency_128m', class 'altmemddr2'
 * The macros are prefixed with 'DDR2_LO_LATENCY_128M_'.
 * The prefix is the slave descriptor.
 */
/* Added compability mode with macro names from "old" design...
 * FIXME: we should really fix drivers instead. but this makes it 
 * easier to switch between old and new design...
 */
/* Nios II Constants */
OUTPUT_FORMAT("elf32-littlenios2", "elf32-littlenios2", "elf32-littlenios2")
OUTPUT_ARCH(nios)
ENTRY(_start) /* Defined in head.S */
jiffies = jiffies_64;
SECTIONS
{
  . = 0xd0000000;
  /*  read-only */
  _stext = . ;
  _text = .; /* Text and read-only data */
  .text : {
    *(.text)
    . = ALIGN(8); __sched_text_start = .; *(.sched.text) __sched_text_end = .;
    . = ALIGN(8); __lock_text_start = .; *(.spinlock.text) __lock_text_end = .;
    *(.fixup)
    *(.gnu.warning)
  } =0
  . = ALIGN(4) ;
  _etext = .; /* End of text section */
  . = ALIGN(32); /* Exception table */
  __start___ex_table = .;
  __ex_table : { *(__ex_table) }
  __stop___ex_table = .;
  . = ALIGN(4096); .rodata : AT(ADDR(.rodata) - 0) { __start_rodata = .; *(.rodata) *(.rodata.*) *(__vermagic) } .rodata1 : AT(ADDR(.rodata1) - 0) { *(.rodata1) } .pci_fixup : AT(ADDR(.pci_fixup) - 0) { __start_pci_fixups_early = .; *(.pci_fixup_early) __end_pci_fixups_early = .; __start_pci_fixups_header = .; *(.pci_fixup_header) __end_pci_fixups_header = .; __start_pci_fixups_final = .; *(.pci_fixup_final) __end_pci_fixups_final = .; __start_pci_fixups_enable = .; *(.pci_fixup_enable) __end_pci_fixups_enable = .; __start_pci_fixups_resume = .; *(.pci_fixup_resume) __end_pci_fixups_resume = .; } .rio_route : AT(ADDR(.rio_route) - 0) { __start_rio_route_ops = .; *(.rio_route_ops) __end_rio_route_ops = .; } __ksymtab : AT(ADDR(__ksymtab) - 0) { __start___ksymtab = .; *(__ksymtab) __stop___ksymtab = .; } __ksymtab_gpl : AT(ADDR(__ksymtab_gpl) - 0) { __start___ksymtab_gpl = .; *(__ksymtab_gpl) __stop___ksymtab_gpl = .; } __ksymtab_unused : AT(ADDR(__ksymtab_unused) - 0) { __start___ksymtab_unused = .; *(__ksymtab_unused) __stop___ksymtab_unused = .; } __ksymtab_unused_gpl : AT(ADDR(__ksymtab_unused_gpl) - 0) { __start___ksymtab_unused_gpl = .; *(__ksymtab_unused_gpl) __stop___ksymtab_unused_gpl = .; } __ksymtab_gpl_future : AT(ADDR(__ksymtab_gpl_future) - 0) { __start___ksymtab_gpl_future = .; *(__ksymtab_gpl_future) __stop___ksymtab_gpl_future = .; } __kcrctab : AT(ADDR(__kcrctab) - 0) { __start___kcrctab = .; *(__kcrctab) __stop___kcrctab = .; } __kcrctab_gpl : AT(ADDR(__kcrctab_gpl) - 0) { __start___kcrctab_gpl = .; *(__kcrctab_gpl) __stop___kcrctab_gpl = .; } __kcrctab_unused : AT(ADDR(__kcrctab_unused) - 0) { __start___kcrctab_unused = .; *(__kcrctab_unused) __stop___kcrctab_unused = .; } __kcrctab_unused_gpl : AT(ADDR(__kcrctab_unused_gpl) - 0) { __start___kcrctab_unused_gpl = .; *(__kcrctab_unused_gpl) __stop___kcrctab_unused_gpl = .; } __kcrctab_gpl_future : AT(ADDR(__kcrctab_gpl_future) - 0) { __start___kcrctab_gpl_future = .; *(__kcrctab_gpl_future) __stop___kcrctab_gpl_future = .; } __markers : AT(ADDR(__markers) - 0) { __start___markers = .; *(__markers) __stop___markers = .; } __ksymtab_strings : AT(ADDR(__ksymtab_strings) - 0) { *(__ksymtab_strings) } __markers_strings : AT(ADDR(__markers_strings) - 0) { *(__markers_strings) } __end_rodata = .; . = ALIGN(4096); __param : AT(ADDR(__param) - 0) { __start___param = .; *(__param) __stop___param = .; __end_rodata = .; } . = ALIGN(4096);
  /* writeable */
  .data : { /* Data */
    /*
     * This ALIGN is needed as a workaround for a bug a gcc bug upto 4.1 which
     * limits the maximum alignment to at most 32kB and results in the following
     * warning:
     *
     *  CC      arch/mips/kernel/init_task.o
     * arch/mips/kernel/init_task.c:30: warning: alignment of ‘init_thread_union’
     * is greater than maximum object file alignment.  Using 32768
     */
    . = ALIGN(8192); /* MUST be 8192, the THREAD_SIZE */
    *(.data.init_task)
    *(.data)
    CONSTRUCTORS
  }
  .lit8 : { *(.lit8) }
  .lit4 : { *(.lit4) }
  /* We want the small data sections together, so single-instruction offsets
     can access them all, and initialized data all before uninitialized, so
     we can shorten the on-disk segment size.  */
  .sdata : { *(.sdata) }
  . = ALIGN(4096);
  __nosave_begin = .;
  .data_nosave : { *(.data.nosave) }
  . = ALIGN(4096);
  __nosave_end = .;
  . = ALIGN(32);
  .data.cacheline_aligned : { *(.data.cacheline_aligned) }
  _edata = .; /* End of data section */
  /* will be freed after init */
  . = ALIGN(4096); /* Init code and data */
  __init_begin = .;
  .init.text : {
 _sinittext = .;
 *(.init.text)
 _einittext = .;
  }
  .init.data : { *(.init.data) }
  . = ALIGN(16);
  __setup_start = .;
  .init.setup : { *(.init.setup) }
  __setup_end = .;
  __initcall_start = .;
  .initcall.init : {
 *(.initcall0.init) *(.initcall0s.init) *(.initcall1.init) *(.initcall1s.init) *(.initcall2.init) *(.initcall2s.init) *(.initcall3.init) *(.initcall3s.init) *(.initcall4.init) *(.initcall4s.init) *(.initcall5.init) *(.initcall5s.init) *(.initcallrootfs.init) *(.initcall6.init) *(.initcall6s.init) *(.initcall7.init) *(.initcall7s.init)
  }
  __initcall_end = .;
  __con_initcall_start = .;
  .con_initcall.init : { *(.con_initcall.init) }
  __con_initcall_end = .;
  .security_initcall.init : AT(ADDR(.security_initcall.init) - 0) { __security_initcall_start = .; *(.security_initcall.init) __security_initcall_end = .; }
    /* .exit.text is discarded at runtime, not link time, to deal with
     references from .rodata */
  .exit.text : { *(.exit.text) }
  .exit.data : { *(.exit.data) }
  . = ALIGN(4096);
  __initramfs_start = .;
  .init.ramfs : { *(.init.ramfs) }
  __initramfs_end = .;
  . = ALIGN(32);
  __per_cpu_start = .;
  .data.percpu : { *(.data.percpu) }
  __per_cpu_end = .;
  . = ALIGN(4096);
  __init_end = .;
  /* freed after init ends here */
  __bss_start = .; /* BSS */
  .sbss : {
    *(.sbss)
    *(.scommon)
  }
  .bss : {
    *(.bss)
    *(COMMON)
  }
  __bss_stop = .;
  _end = . ;
  /* Sections to be discarded */
  /DISCARD/ : {
 *(.exit.text)
 *(.exit.data)
        *(.exitcall.exit)
  }
  .stab 0 : { *(.stab) } .stabstr 0 : { *(.stabstr) } .stab.excl 0 : { *(.stab.excl) } .stab.exclstr 0 : { *(.stab.exclstr) } .stab.index 0 : { *(.stab.index) } .stab.indexstr 0 : { *(.stab.indexstr) } .comment 0 : { *(.comment) }
  .debug 0 : { *(.debug) } .line 0 : { *(.line) } .debug_srcinfo 0 : { *(.debug_srcinfo) } .debug_sfnames 0 : { *(.debug_sfnames) } .debug_aranges 0 : { *(.debug_aranges) } .debug_pubnames 0 : { *(.debug_pubnames) } .debug_info 0 : { *(.debug_info .gnu.linkonce.wi.*) } .debug_abbrev 0 : { *(.debug_abbrev) } .debug_line 0 : { *(.debug_line) } .debug_frame 0 : { *(.debug_frame) } .debug_str 0 : { *(.debug_str) } .debug_loc 0 : { *(.debug_loc) } .debug_macinfo 0 : { *(.debug_macinfo) } .debug_weaknames 0 : { *(.debug_weaknames) } .debug_funcnames 0 : { *(.debug_funcnames) } .debug_typenames 0 : { *(.debug_typenames) } .debug_varnames 0 : { *(.debug_varnames) }
  /* These must appear regardless of  .  */
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }
  .note : { *(.note) }
}
